---
breadcrumb_title: >-
  IA comme Algorithme
title: >-
  IA comme Algorithme
bodyclass: >-
   
url: "/manifeste/mode-ia/ia-algorithme/"
slug: "ia-algorithme"
aliases:
  - /manifeste-technorealiste-sur-lia/a-lencontre-de-quelques-lubies-dominantes-sur-lia/des-notions-contestables-inutiles-voire-trompeuses/lia-comme-algorithme/
  - /manifeste/lubies/notions-contestables/algorithme/
  - /manifeste/mode-ia/notions-contestables/ia-algorithme/
  - /manifeste-technorealiste-sur-lia/lia-comme-algorithme/
  - /manifeste-technorealiste-sur-lia/a-lencontre-de-quelques-lubies-dominantes-sur-lia/lia-comme-algorithme/
date: 2023-09-25T11:46:15+02:00
lastmod: 2025-05-18T20:34:00+02:00
meta:
  hugo:
    permalink: "/manifeste/mode-ia/ia-algorithme/"
    path: "/pages/manifeste/mode-ia/ia-algorithme"
    file: "content/fr/pages/manifeste/mode-ia/ia-algorithme/_index.html"
    slug: "ia-algorithme"
  dates:
    created_at: 2023-08-31T14:11:09+02:00
    updated_at: 2025-05-18T20:34:00+02:00
    published_at: 2023-09-25T11:46:15+02:00
search:
  id: "062f6550-9bbc-419c-9868-cd8fa8fa90c8"
  about_id: "2c6142e3-18fc-4750-af0e-36b902d867b9"
  url: "/manifeste/mode-ia/ia-algorithme/"
  kind: "Communication::Website::Page::Localization"
  lang: "fr"
  title: >-
    IA comme Algorithme
  summary: >-
    <p>Illusion de transparence</p>
  body: >-
    <p>  <br>Algorithme  n’est pas un bon terme, parce qu’il suggère que  la recette dans le livre  soit la même chose que  l’action de cuisiner réellement .</p>  <p> Définition  <br>   <br>Un algorithme est la description d'une suite d'instructions permettant d'obtenir un résultat à partir d'éléments fournis en entrée (donc une série de règles ou d'instructions étape par étape qui guident le processus de prise de décision ou de résolution de problèmes). La notion d'algorithme permet de décrire une logique théorique d'un traitement de données. En IA, spécifiquement, l'algorithme peut être défini comme une série d'instructions opératoires décrites par des formules mathématiques, et dont le but est de réduire l'erreur par modification automatique des poids dans un modèle. Il a quelque part été relevé que l’usage public du mot  algorithme  relève d’une  utilisation trop simplifiée .  1 Nous le confirmons : dans un ordinateur, on peine à identifier ce qu’est un algorithme. Comme  suite d’instructions , l’algorithme en toute rigueur devrait être fini… mais au contraire, un ordinateur fonctionne grâce à des programmes, qui peuvent opérer des boucles de traitement, et donc travailler de manière in(dé)finie ! Autre distance algorithme/programme : alors que l’algorithme est une suite théorique d’instructions, une procédure générale, un programme, c'est l’écriture de ces instructions dans un langage de programmation particulier. On dit qu’un programme implémente un ou plusieurs algorithmes. Nous devons alors insister sur le caractère abstrait de l’algorithme, qui suppose d’ignorer les détails d’implémentation (choix du langage et du cadre (framework) de programmation, architecture logicielle,  clustering , etc). 2 Parler d’algorithme, c’est choisir le seul regard du logicien, qui est loin d’épuiser la réalité : d’autres regards complémentaires sont nécessaires pour parler un peu mieux du réel (le regard de l’utilisateur, de l'administrateur, du programmeur, etc.) Le programme et l’algorithme ne sont pas déterministes de la même manière, au sens où le programme est soumis à modification en cas de changement de variables. Un programme peut certes  embarquer  certaines séquences de code, non changeantes, qualifiables d’algorithmes. Mais, selon certains auteurs, on ne doit parler d’algorithme qu’à un stade de réduction avancée. 3  Quoi qu’il en soit, la notion de programme appelle celle de finitude ou non-terminaison. La non-terminaison inhérente au traitement de programmes implique que l' opcode  devant être exécuté peut être conservé dans un compteur de programme, qui est ensuite incrémenté de manière séquentielle après l'exécution de chaque  opcode . Cependant, certains  opcodes , tels que les instructions de saut ( jump ), peuvent de modifier la valeur du compteur de programme, ce qui peut entraîner une boucle d'exécution : on comprend ici que si un programme mettait un temps infini pour donner une réponse, il ne servirait potentiellement à rien… Pourtant, le temps d’exécution ( uptime ) est paramétrable et on récupère ici, un caractère de finitude typique de l’algorithme.  <br>1  Alberto Naibo qui travaille sur la définition de l'algorithme : Or la notion d’algorithme est l’une des notions les plus présentes dans le débat public actuel. Ce débat est généralement dominé par un style de discussion journalistique, où des déclarations sont faites afin de polariser la discussion autour de scénarios futurs, positifs ou négatifs, concernant les impacts économiques, politiques et sociaux des algorithmes. Ces discussions n’explicitent cependant jamais ce qu’est un algorithme, et lorsqu’elles le font, une image trop simplifiée en est souvent donnée (un algorithme sera, par exemple, comparé à une recette de pâtisserie). 2  L'approche de Yuri Gurevich pour définir un algorithme est fondée sur la notion d'une machine à états abstraite. Un algorithme est considéré comme un ensemble d'instructions qui opèrent sur des états abstraits, les transformant en nouveaux états. Cette définition permet différents modèles de calcul et capture l'essence du calcul indépendamment des détails d'implémentation spécifiques. 3  Selon la complexité de Kolmogorov, un algorithme est défini en termes de théorie de l'information. Il considère un algorithme comme la description la plus courte possible (en termes de bits) d'un objet spécifique ou du processus permettant de le générer. L'algorithme qui produit l'objet avec la description la plus courte est considéré comme le plus efficace.</p>  <p> Problème  <br>   <br>Le problème théorique de finitude algorithmique est toujours négligé, de sorte que ce que nous lisons partout, suggère que l’algorithme serait une sorte de petite machine opératoire, ce qui est très faux si nous avons lu nos développements sur l’ opcode . Or, nous l’avons vu : lorsque l'ensemble des étapes algorithmiques (y compris les appels aux autres algorithmes) est mal défini, est ambigu, ne se termine pas, ou ne vise pas à résoudre un problème spécifique, on ne devrait pas parler d’algorithme. Algorithme  est le plus souvent employé pour désigner, en réalité, le  programme . Or un programme qui  boucle  met un temps infini, et donc ne peut plus être qualifié d’algorithme. Le travail des juristes, publicitaires et éthiciens, en insistant sur la mauvaise qualité des algorithmes, ou leur caractère éventuellement discriminatoire, nous trompe : ils inventent un monde imaginaire, où il y aurait des  machines algorithmiques  que l’on pourrait caractériser, dont on pourrait reconnaître les effets, et donc améliorer. Par exemple, lorsqu’on s’intéresse au caractère discriminatoire du prétendu algorithme de Parcoursup (en fait, la partie informatisée du processus), on cesse d’envisager cela, que ladite discrimination peut provenir des données, des modèles, ou encore du simple fait d’utiliser l’informatique. On voit que l’algorithme a bon dos.  Tout aussi trompeur : les réflexions sur la  gouvernance algorithmique , qui suggèrent quelqu’un choisissant les mauvais algorithmes, ou les contrôlant. Ce n’est pas réel : il y a en revanche des personnes (les informaticiens) qui s’occupent des programmes logiciels, et leur travail ne se résume nullement au choix entre les meilleures et les moins bonnes petites “machines algorithmiques”. Il n’y a dans la réalité que des ordinateurs, sur lesquels tournent principalement des programmes, et par exception quelques rares algorithmes, sauf à employer une définition très large qui en perd le sens et la notion clé de terminaison.</p>  <p> Proposition  <br>   <br>Algorithme  peut convenir, dans des situations très spécifiques : par exemple, l’algorithme GPT de ChatGPT pourrait être assimilé à une  intelligence  (en fait, une fonction calculatoire) de type algorithmique, parce qu'elle utilise un réseau de neurones, mais également, car elle est capable de faire le lien entre certains domaines sémantiques non apparemment corrélés. Il faudrait réserver le terme algorithme à certains cas, comme lorsqu’il s’agit de désigner les suites finies de calculs lors de la phase d’entraînement. Mais, pour le reste, en particulier à partir de la mise en production, on devrait plutôt parler du programme. Le programme, c’est ce qui est présent dans les ordinateurs réels : dans certains cas seulement, le programme est déterministe, au sens que l’on peut connaître à l’avance quelles informations viendront s’ajouter lors de son exécution. Dans ces cas uniquement, on pourrait éventuellement parler d’algorithmes. 1 Il faudrait encore ici se méfier : la modification du programme peut être  connue  comme aléatoire (étant précisé que l’aléa en informatique est simulé à partir de techniques, logicielles ou matérielles particulières). Dans ce cas encore, il redevient contestable et trompeur de discuter d’algorithme. <br>1  Au sens de la définition d'un algorithme par Donald Knuth. Si l’on veut privilégier une autre définition, on retombe alors sur ce problème de la distinction programme/algorithme. Par exemple, sur la base des travaux d’Alberto Naibo, nous pouvons synthétiser les définitions de ce qu'est un algorithme de la manière suivante : un algorithme est le processus de résolution d’un système d’équation et peut avoir certaines dimensions aléatoires et non déterministes. En informatique, l’algorithme est implémenté sous forme de programme. Un même programme peut exécuter différents algorithmes.</p>

breadcrumbs:
  - title: >-
      Technorealisme.org
    path: "/"
  - title: >-
      Manifeste
    path: "/manifeste/"
  - title: >-
      La mode de l'IA
    path: "/manifeste/mode-ia/"
  - title: >-
      IA comme Algorithme

design:
  full_width: false
  toc:
    present: true
    offcanvas: false


position: 1
weight: 1

translationKey: communication-website-page-2c6142e3-18fc-4750-af0e-36b902d867b9



meta_description: >-
  IA comme Algorithme : Illusion de transparence

summary: >-
  <p>Illusion de transparence</p>

header_text: >-
  
header_cta:


contents_reading_time:
  seconds: 369
  text: >-
    6 minutes
contents:
  - kind: block
    template: chapter
    title: >-
      
    slug: >-
      
    ranks:
      base: 2
    top:
      active: false
    data:
      layout: accent_background
      text: >-
        <p><i>Algorithme</i> n’est pas un bon terme, parce qu’il suggère que <i>la recette dans le livre</i> soit la même chose que <i>l’action de cuisiner réellement</i>.</p>

      notes: >-
        


      alt: >-
        

      credit: >-
        



  - kind: block
    template: title
    title: >-
      Définition
    slug: >-
      definition
    ranks:
      base: 2
      self: 2
    top:
      active: true
      title: 
        value: >-
          Définition
        heading: 2
    data:
      layout: classic


  - kind: block
    template: chapter
    title: >-
      
    slug: >-
      
    ranks:
      base: 3
    top:
      active: false
    data:
      layout: no_background
      text: >-
        <p>Un algorithme est la description d'une suite d'instructions permettant d'obtenir un résultat à partir d'éléments fournis en entrée (donc une série de règles ou d'instructions étape par étape qui guident le processus de prise de décision ou de résolution de problèmes). La notion d'algorithme permet de décrire une logique théorique d'un traitement de données. En IA, spécifiquement, l'algorithme peut être défini comme une série d'instructions opératoires décrites par des formules mathématiques, et dont le but est de réduire l'erreur par modification automatique des poids dans un modèle.</p><p>Il a quelque part été relevé que l’usage public du mot <i>algorithme</i> relève d’une <i>utilisation trop simplifiée</i>. <sup>1</sup></p><p>Nous le confirmons : dans un ordinateur, on peine à identifier ce qu’est un algorithme. Comme <i>suite d’instructions</i>, l’algorithme en toute rigueur devrait être fini… mais au contraire, un ordinateur fonctionne grâce à des programmes, qui peuvent opérer des boucles de traitement, et donc travailler de manière in(dé)finie ! Autre distance algorithme/programme : alors que l’algorithme est une suite théorique d’instructions, une procédure générale, un programme, c'est l’écriture de ces instructions dans un langage de programmation particulier. On dit qu’un programme implémente un ou plusieurs algorithmes.</p><p>Nous devons alors insister sur le caractère abstrait de l’algorithme, qui suppose d’ignorer les détails d’implémentation (choix du langage et du cadre (framework) de programmation, architecture logicielle, <i>clustering</i>, etc).<sup>2</sup></p><p>Parler d’algorithme, c’est choisir le seul regard du logicien, qui est loin d’épuiser la réalité : d’autres regards complémentaires sont nécessaires pour parler un peu mieux du réel (le regard de l’utilisateur, de l'administrateur, du programmeur, etc.)</p><p>Le programme et l’algorithme ne sont pas déterministes de la même manière, au sens où le programme est soumis à modification en cas de changement de variables. Un programme peut certes <i>embarquer</i> certaines séquences de code, non changeantes, qualifiables d’algorithmes. Mais, selon certains auteurs, on ne doit parler d’algorithme qu’à un stade de réduction avancée.<sup>3</sup> Quoi qu’il en soit, la notion de programme appelle celle de finitude ou non-terminaison.</p><p>La non-terminaison inhérente au traitement de programmes implique que l'<i>opcode</i> devant être exécuté peut être conservé dans un compteur de programme, qui est ensuite incrémenté de manière séquentielle après l'exécution de chaque <i>opcode</i>. Cependant, certains <i>opcodes</i>, tels que les instructions de saut (<i>jump</i>), peuvent de modifier la valeur du compteur de programme, ce qui peut entraîner une boucle d'exécution : on comprend ici que si un programme mettait un temps infini pour donner une réponse, il ne servirait potentiellement à rien… Pourtant, le temps d’exécution (<i>uptime</i>) est paramétrable et on récupère ici, un caractère de finitude typique de l’algorithme. </p>

      notes: >-
        <p><sup>1</sup> Alberto Naibo qui travaille sur la définition de l'algorithme : Or la notion d’algorithme est l’une des notions les plus présentes dans le débat public actuel. Ce débat est généralement dominé par un style de discussion journalistique, où des déclarations sont faites afin de polariser la discussion autour de scénarios futurs, positifs ou négatifs, concernant les impacts économiques, politiques et sociaux des algorithmes. Ces discussions n’explicitent cependant jamais ce qu’est un algorithme, et lorsqu’elles le font, une image trop simplifiée en est souvent donnée (un algorithme sera, par exemple, comparé à une recette de pâtisserie).</p><p><sup>2</sup> L'approche de Yuri Gurevich pour définir un algorithme est fondée sur la notion d'une machine à états abstraite. Un algorithme est considéré comme un ensemble d'instructions qui opèrent sur des états abstraits, les transformant en nouveaux états. Cette définition permet différents modèles de calcul et capture l'essence du calcul indépendamment des détails d'implémentation spécifiques.</p><p><sup>3</sup> Selon la complexité de Kolmogorov, un algorithme est défini en termes de théorie de l'information. Il considère un algorithme comme la description la plus courte possible (en termes de bits) d'un objet spécifique ou du processus permettant de le générer. L'algorithme qui produit l'objet avec la description la plus courte est considéré comme le plus efficace.</p>


      alt: >-
        

      credit: >-
        



  - kind: block
    template: title
    title: >-
      Problème
    slug: >-
      probleme
    ranks:
      base: 2
      self: 2
    top:
      active: true
      title: 
        value: >-
          Problème
        heading: 2
    data:
      layout: classic


  - kind: block
    template: chapter
    title: >-
      
    slug: >-
      
    ranks:
      base: 3
    top:
      active: false
    data:
      layout: no_background
      text: >-
        <p>Le problème théorique de finitude algorithmique est toujours négligé, de sorte que ce que nous lisons partout, suggère que l’algorithme serait une sorte de petite machine opératoire, ce qui est très faux si nous avons lu nos développements sur l’<i>opcode</i>. Or, nous l’avons vu : lorsque l'ensemble des étapes algorithmiques (y compris les appels aux autres algorithmes) est mal défini, est ambigu, ne se termine pas, ou ne vise pas à résoudre un problème spécifique, on ne devrait pas parler d’algorithme.</p><p><i>Algorithme</i> est le plus souvent employé pour désigner, en réalité, le <i>programme</i>. Or un programme qui <i>boucle</i> met un temps infini, et donc ne peut plus être qualifié d’algorithme.</p><p>Le travail des juristes, publicitaires et éthiciens, en insistant sur la mauvaise qualité des algorithmes, ou leur caractère éventuellement discriminatoire, nous trompe : ils inventent un monde imaginaire, où il y aurait des <i>machines algorithmiques</i> que l’on pourrait caractériser, dont on pourrait reconnaître les effets, et donc améliorer. Par exemple, lorsqu’on s’intéresse au caractère discriminatoire du prétendu algorithme de Parcoursup (en fait, la partie informatisée du processus), on cesse d’envisager cela, que ladite discrimination peut provenir des données, des modèles, ou encore du simple fait d’utiliser l’informatique. On voit que l’algorithme a bon dos. </p><p>Tout aussi trompeur : les réflexions sur la <i>gouvernance algorithmique</i>, qui suggèrent quelqu’un choisissant les mauvais algorithmes, ou les contrôlant. Ce n’est pas réel : il y a en revanche des personnes (les informaticiens) qui s’occupent des programmes logiciels, et leur travail ne se résume nullement au choix entre les meilleures et les moins bonnes petites “machines algorithmiques”.</p><p>Il n’y a dans la réalité que des ordinateurs, sur lesquels tournent principalement des programmes, et par exception quelques rares algorithmes, sauf à employer une définition très large qui en perd le sens et la notion clé de terminaison.</p>

      notes: >-
        


      alt: >-
        

      credit: >-
        



  - kind: block
    template: title
    title: >-
      Proposition
    slug: >-
      proposition
    ranks:
      base: 2
      self: 2
    top:
      active: true
      title: 
        value: >-
          Proposition
        heading: 2
    data:
      layout: classic


  - kind: block
    template: chapter
    title: >-
      
    slug: >-
      
    ranks:
      base: 3
    top:
      active: false
    data:
      layout: no_background
      text: >-
        <p><i>Algorithme</i> peut convenir, dans des situations très spécifiques : par exemple, l’algorithme GPT de ChatGPT pourrait être assimilé à une <i>intelligence</i> (en fait, une fonction calculatoire) de type algorithmique, parce qu'elle utilise un réseau de neurones, mais également, car elle est capable de faire le lien entre certains domaines sémantiques non apparemment corrélés.</p><p>Il faudrait réserver le terme algorithme à certains cas, comme lorsqu’il s’agit de désigner les suites finies de calculs lors de la phase d’entraînement. Mais, pour le reste, en particulier à partir de la mise en production, on devrait plutôt parler du programme. Le programme, c’est ce qui est présent dans les ordinateurs réels : dans certains cas seulement, le programme est déterministe, au sens que l’on peut connaître à l’avance quelles informations viendront s’ajouter lors de son exécution. Dans ces cas uniquement, on pourrait éventuellement parler d’algorithmes.<sup>1</sup></p><p>Il faudrait encore ici se méfier : la modification du programme peut être <i>connue</i> comme aléatoire (étant précisé que l’aléa en informatique est simulé à partir de techniques, logicielles ou matérielles particulières). Dans ce cas encore, il redevient contestable et trompeur de discuter d’algorithme.</p>

      notes: >-
        <p><sup>1 </sup>Au sens de la définition d'un algorithme par Donald Knuth. Si l’on veut privilégier une autre définition, on retombe alors sur ce problème de la distinction programme/algorithme. Par exemple, sur la base des travaux d’Alberto Naibo, nous pouvons synthétiser les définitions de ce qu'est un algorithme de la manière suivante : un algorithme est le processus de résolution d’un système d’équation et peut avoir certaines dimensions aléatoires et non déterministes. En informatique, l’algorithme est implémenté sous forme de programme. Un même programme peut exécuter différents algorithmes.</p>


      alt: >-
        

      credit: >-
        




---
