---
title: >-
  L’IA comme algorithme, l’illusion de transparence
breadcrumb_title: >-
  L’IA comme algorithme, l’illusion de transparence
breadcrumbs:
  - title: >-
      Accueil
    path: "/"
  - title: >-
      Manifeste technoréaliste sur l’IA
    path: "/manifeste-technorealiste-sur-lia/"
  - title: >-
      Lubies dominantes
    path: "/manifeste-technorealiste-sur-lia/a-lencontre-de-quelques-lubies-dominantes-sur-lia/"
  - title: >-
      Des notions contestables, inutiles voire trompeuses
    path: "/manifeste-technorealiste-sur-lia/a-lencontre-de-quelques-lubies-dominantes-sur-lia/des-notions-contestables-inutiles-voire-trompeuses/"
  - title: >-
      L’IA comme algorithme, l’illusion de transparence
url: "/manifeste-technorealiste-sur-lia/a-lencontre-de-quelques-lubies-dominantes-sur-lia/des-notions-contestables-inutiles-voire-trompeuses/lia-comme-algorithme/"
slug: "lia-comme-algorithme"
aliases:
  - /manifeste-technorealiste-sur-lia/lia-comme-algorithme/
  - /manifeste-technorealiste-sur-lia/a-lencontre-de-quelques-lubies-dominantes-sur-lia/lia-comme-algorithme/

full_width: false
design:
  full_width: false
  toc:
    present: true
    offcanvas: false

position: 1
weight: 1
translation_key: communication-website-page-2c6142e3-18fc-4750-af0e-36b902d867b9

bodyclass: 
image:
  id: "3cb699f8-e819-4d02-9923-9de0da2e826b"
  alt: ""
  credit: >-
    <p>Photo by <a href="https://unsplash.com/@barbarazandoval?utm_source=osuny&amp;utm_medium=referral"> Barbara Zandoval</a> on <a href="https://unsplash.com/?utm_source=osuny&amp;utm_medium=referral">Unsplash</a></p>

meta_description: >
  
description: >
  

summary: >
  “Algorithme” n’est pas un bon terme, parce qu’il suggère que la “recette dans le livre” est la même chose que “l’action de cuisiner réellement”

header_text: >-
  
header_cta:
  display: false
  label: 
  target: 
contents_reading_time:
  seconds: 367
  text: >-
    6 minutes
contents:
  - kind: heading
    title: >-
      Définition courante
    position: 1
    rank: 2
  - kind: block
    template: chapter
    title: >-
      
    ranks:
      self: false
    data:
      layout: no_background
      text: >-
        <p>Un algorithme est la description d'une suite d’instructions permettant d'obtenir un résultat à partir d'éléments fournis en entrée (donc une série de règles ou d'instructions étape par étape qui guident le processus de prise de décision ou de résolution de problèmes). La notion d’algorithme permet de décrire une logique théorique d’un traitement de données. En IA, spécifiquement, l’algorithme peut être défini comme une série d'instructions opératoires décrites par des formules mathématiques, et dont le but est de réduire l'erreur par modification automatique des poids dans un modèle. </p>

      notes: >-
        


      alt: >-
        

      credit: >-
        




  - kind: heading
    title: >-
      Points d’attention
    position: 2
    rank: 2
  - kind: block
    template: chapter
    title: >-
      
    ranks:
      self: false
    data:
      layout: no_background
      text: >-
        <p>Il a quelque part été relevé que l’usage public du mot “algorithme” relève d’une “utilisation trop simplifiée." <sup>[1]</sup> </p><p>Nous le confirmons : dans un ordinateur, on a du mal à identifier ce qu’est un algorithme. En tant que “suite d’instructions”, l’algorithme en toute rigueur devrait être fini… mais au contraire, un ordinateur fonctionne grâce à des programmes, qui peuvent opérer des boucles de traitement, et donc travailler de manière in(dé)finie ! Autre distance algorithme/programme : alors que l’algorithme est une suite théorique d’instructions, une procédure générale, un programme c’est l’écriture de ces instructions dans un langage de programmation particulier. On dit qu’un programme implémente un ou plusieurs algorithmes.</p><p>Nous devons alors insister sur le caractère abstrait de l’algorithme, qui suppose d’ignorer les détails d’implémentation (choix du langage et du cadre (framework) de programmation, architecture logiciel, clustering etc). <sup>[2]</sup></p><p>Parler d’algorithme, c’est choisir le seul regard du logicien, qui est loin d’épuiser la réalité : d’autres regards complémentaires sont nécessaires pour parler un peu mieux du réel (le regard de l’utilisateur, de l'administrateur, du programmeur etc.)</p><p>Le programme et l’algorithme ne sont pas déterministes de la même manière, au sens où le programme est soumis à modification en cas de changement de variables. Un programme peut certes “embarquer“ certaines séquences de code, non changeantes, qualifiables d’algorithmes. Mais selon certains auteurs, on ne doit parler d’algorithme qu’à un stade de réduction avancée. <sup>[3]</sup> Quoi qu’il en soit, la notion de programme appelle celle de finitude ou non-terminaison.</p><p>La non-terminaison inhérente au traitement de programmes implique que l'opcode devant être exécuté peut être conservé dans un compteur de programme, qui est ensuite incrémenté de manière séquentielle après l'exécution de chaque opcode. Cependant, certains opcodes, tels que les instructions de saut (jump), ont la capacité de modifier la valeur du compteur de programme, ce qui peut entraîner une boucle d'exécution : on comprend ici que si un programme mettait un temps infini pour donner une réponse, il ne servirait potentiellement à rien…  Pourtant le temps d’exécution (uptime) est paramétrable et on récupère ici, un caractère de finitude typique de l’algorithme. </p>

      notes: >-
        <p><sup>[1]</sup> Alberto Naibo qui travaille sur la définition de l'algorithme   : "Or la notion d’algorithme est l’une des notions les plus présentes dans le débat public actuel. Ce débat est généralement dominé par un style de discussion journalistique, où des déclarations sont faites afin de polariser la discussion autour de scénarios futurs, positifs ou négatifs, concernant les impacts économiques, politiques et sociaux des algorithmes. Ces discussions n’explicitent cependant jamais ce qu’est un algorithme, et lorsqu’elles le font, une image trop simplifiée en est souvent donnée (un algorithme sera par exemple comparé à une recette de pâtisserie). " https  ://observatoire-ia.pantheonsorbonne.fr/entretien-alberto-naibo-geometrie-algorithmes</p><p><sup>[2]</sup> L'approche de Yuri Gurevich pour définir un algorithme est basée sur la notion d'une machine à états abstraite. Un algorithme est considéré comme un ensemble d'instructions qui opèrent sur des états abstraits, les transformant en nouveaux états. Cette définition permet différents modèles de calcul et capture l'essence du calcul indépendamment des détails d'implémentation spécifiques.</p><p><sup>[3]</sup> Selon la complexité de Kolmogorov, un algorithme est défini en termes de théorie de l'information. Il considère un algorithme comme la description la plus courte possible (en termes de bits) d'un objet spécifique ou du processus permettant de le générer. L'algorithme qui produit l'objet avec la description la plus courte est considéré comme le plus efficace.</p>


      alt: >-
        

      credit: >-
        




  - kind: heading
    title: >-
      Erreurs communes
    position: 3
    rank: 2
  - kind: block
    template: chapter
    title: >-
      
    ranks:
      self: false
    data:
      layout: no_background
      text: >-
        <p>Le problème théorique de finitude algorithmique est toujours négligé, de sorte que ce que nous lisons partout, suggère que l’algorithme serait une sorte de petite machine opératoire, ce qui est très faux si on a lu nos développements sur l’opcode. Or nous l’avons vu : lorsque l'ensemble des étapes algorithmiques (y compris les appels aux autres algorithmes) n’est pas bien défini, est ambigu, ne se termine pas, ou ne vise pas à résoudre un problème spécifique, on ne devrait pas parler d’algorithme.</p><p>“Algorithme” est le plus souvent employé pour désigner en fait, le “programme”. Or un programme qui “boucle” met un temps infini, et donc ne peut plus être qualifié d’algorithme.</p><p>Le travail des juristes, publicitaires et éthiciens, en insistant sur la mauvaise qualité des algorithmes, ou leur caractère éventuellement discriminatoire, nous trompe : ils inventent un monde imaginaire, où il y aurait des “machines algorithmiques” que l’on pourrait caractériser, dont on pourrait reconnaître les effets, et donc améliorer. Par exemple, lorsqu’on s’intéresse au caractère discriminatoire du soi-disant algorithme de Parcoursup (en fait, la partie informatisée du processus), on cesse d’envisager cela, que ladite discrimination peut provenir des données, du modèles, ou encore du simple fait d’utiliser l’informatique. On voit que l’algorithme a bon dos. </p><p>Tout aussi trompeur : les réflexions sur la “gouvernance algorithmique”, qui suggèrent quelqu’un choisissant les mauvais algorithmes, ou les contrôlant. Ce n’est pas réel : il y a en revanche des gens (les informaticiens) qui s’occupent des programmes logiciels, et leur travail ne se résume nullement au choix entre les meilleures et les moins bonnes petites “machines algorithmiques”.</p><p>ll n’y a dans la réalité que des ordinateurs, sur lesquels tournent principalement des programmes, et par exception quelques rares algorithmes, sauf à employer une définition très large qui en perd le sens, et la notion clé de terminaison.</p>

      notes: >-
        


      alt: >-
        

      credit: >-
        




  - kind: heading
    title: >-
      Proposition
    position: 4
    rank: 2
  - kind: block
    template: chapter
    title: >-
      
    ranks:
      self: false
    data:
      layout: no_background
      text: >-
        <p>“Algorithme” peut convenir, dans des situations très spécifiques : par exemple, l’algorithme GPT de ChatGPT pourrait être assimilé à une “intelligence” (en fait, une fonction calculatoire) de type algorithmique, parce qu'elle utilise un réseau de neurones mais aussi car elle est capable de faire le lien entre certains domaines sémantiques non apparemment corrélés.</p><p>Il faudrait réserver le terme algorithme à certains cas, comme lorsqu’il s’agit de désigner les suites finies de calculs au cours de la phase d’entraînement. Mais pour le reste, en particulier à partir de la mise en production, on devrait plutôt parler du programme. Le programme, c’est ce qui est présent dans les ordinateurs réels : dans certains cas seulement, le programme est déterministe au sens que l’on peut connaître à l’avance quelles informations viendront s’ajouter lors de son exécution. Dans ces cas seulement, on pourrait éventuellement parler d’algorithmes. <sup>[1]</sup></p><p>Il faudrait encore ici se méfier : la modification du programme peut être “connue” comme aléatoire (étant précisé que l’aléa en informatique est simulé à partir de techniques, logicielles ou matérielles particulières). Dans ce cas encore, il redevient contestable et trompeur de parler d’algorithme.</p>

      notes: >-
        <p><sup>[1] </sup>au sens de la définition d'un algorithme par Donald Knuth https  ://fr.wikipedia.org/wiki/Donald_Knuth. Si l’on veut privilégier une autre définition, on retombe alors sur ce problème de la distinction programme/algorithme. Par ex. sur la base des travaux d’Alberto Naibo, nous pouvons synthétiser les définitions de ce qu'est un algorithme de la manière suivante   : Un algorithme est le processus de résolution d’un système d’équation et peut avoir certaines dimensions aléatoires et non-déterministes. En informatique, l’algorithme est implémenté sous forme de programme. Un même programme peut exécuter différents algorithmes. »</p>


      alt: >-
        

      credit: >-
        





---
